# ğŸš€ é¡¹ç›®ä»£å·ï¼šProject Z-Tide (å°¸æ½®) å¼€å‘æ‰§è¡Œç™½çš®ä¹¦

ç›®æ ‡ï¼šæ„å»ºä¸€ä¸ªåŸºäº WebGL çš„é«˜æ€§èƒ½ Hybrid SLGã€‚

æ ¸å¿ƒå–ç‚¹ï¼š3000+ æµä½“ä¸§å°¸åŒå±ï¼ˆTechï¼‰ + æ‹–æ‹½åˆæˆç©æ³•ï¼ˆLoopï¼‰ã€‚

## ğŸ› ï¸ 0. æŠ€æœ¯æ ˆå¼ºåˆ¶è§„èŒƒ (Tech Stack Mandate)

ä¸ºäº†ç¡®ä¿é«˜æ€§èƒ½å’Œå•†ä¸šåŒ–æ‰©å±•æ€§ï¼Œè¯·ä¸¥æ ¼é”å®šä»¥ä¸‹æŠ€æœ¯æ ˆï¼š

- **æ ¸å¿ƒå¼•æ“**: `Pixi.js v8+` (å¤„ç†æµ·é‡åƒµå°¸æ¸²æŸ“ï¼Œä¸¥ç¦ä½¿ç”¨ DOM)ã€‚
- **UI æ¡†æ¶**: `React` + `TailwindCSS` (å¤„ç†åˆæˆã€èœå•ã€å•†åŸï¼Œè¦†ç›–åœ¨ Canvas ä¸Šå±‚)ã€‚
- **è¯­è¨€**: `TypeScript` (Strict Mode)ã€‚
- **æ¶æ„æ¨¡å¼**: `Dual-Layer Architecture` (åŒå±‚æ¶æ„)ã€‚
    - åº•å±‚ï¼š**Game Layer** (Pixi + ECS) â€”â€” è´Ÿè´£è·‘æ•°æ®å’Œæ¸²æŸ“ã€‚
    - é¡¶å±‚ï¼š**UI Layer** (React + Zustand) â€”â€” è´Ÿè´£äº¤äº’å’Œä¸šåŠ¡é€»è¾‘ã€‚
- **æ•°æ®ç»“æ„**: å¿…é¡»ä½¿ç”¨ `TypedArray` (Uint8Array / Float32Array) å­˜å‚¨ç½‘æ ¼å’Œæµåœºæ•°æ®ã€‚

---

## ğŸ“… Phase 1: æ ¸å¿ƒå¼•æ“ â€”â€” "æµä½“å°¸æ½®" (The Fluid Engine)

**å‘¨æœŸç›®æ ‡**ï¼šå®Œæˆæ ¸å¿ƒæŠ€æœ¯å£å’ã€‚å®ç°â€œåƒæ°´æµä¸€æ ·â€çš„ä¸§å°¸å¯»è·¯ï¼Œå¹¶åœ¨å±å¹•ä¸Šæµç•…æ¸²æŸ“ 3000+ ä¸ªå•ä½ã€‚

### 1.1 æ ¸å¿ƒç®—æ³•ï¼šæµåœºå¯»è·¯ (Flow Field)

è¿™æ˜¯æ›¿ä»£ A* çš„å…³é”®ã€‚ä¸è¦ä½¿ç”¨ NavMeshã€‚

- **Integration Field (çƒ­åŠ›å›¾)**: ä½¿ç”¨ Dijkstra ç®—æ³•ã€‚ç›®æ ‡ç‚¹ï¼ˆåŸºåœ°ï¼‰å€¼ä¸º 0ï¼Œéšœç¢ç‰©ï¼ˆå¢™ï¼‰å€¼ä¸º 65535ã€‚ä»ç›®æ ‡ç‚¹ BFS æ‰©æ•£ï¼Œè®¡ç®—æ¯ä¸ªæ ¼å­åˆ°ç›®æ ‡çš„è·ç¦»ã€‚
- **Vector Field (æµé€Ÿåœº)**: éå†æ¯ä¸ªæ ¼å­ï¼Œæ£€æŸ¥å…¶ 8 ä¸ªé‚»å±…ï¼Œæ‰¾åˆ°è·ç¦»å€¼æœ€å°çš„é‚£ä¸ªï¼Œç”ŸæˆæŒ‡å‘è¯¥é‚»å±…çš„å•ä½å‘é‡ã€‚

### 1.2 æ¸²æŸ“æ–¹æ¡ˆ

- **ä¸§å°¸**: ä½¿ç”¨ `PIXI.ParticleContainer` (æˆ– v8 çš„ InstancedMesh)ã€‚
- **é€»è¾‘**: ä¸§å°¸ä¸è¿›è¡Œå¯»è·¯è®¡ç®—ã€‚æ¯å¸§ç›´æ¥è¯»å–è„šä¸‹æ ¼å­çš„ `Vector` ä½œä¸ºåŠ é€Ÿåº¦ã€‚
- **ç‰©ç†**: å®ç°ç®€å•çš„**åˆ†ç¦»åŠ› (Separation)**ã€‚å¦‚æœä¸¤ä¸ªä¸§å°¸å¤ªè¿‘ï¼Œæ–½åŠ åå‘æ¨åŠ›ï¼ˆæ¨¡æ‹Ÿæµä½“ä¸å¯å‹ç¼©æ€§ï¼‰ã€‚

### ğŸ’» [IDE Agent æŒ‡ä»¤ - Phase 1]

**è¯·å¤åˆ¶ä»¥ä¸‹å†…å®¹ç»™ä½ çš„ AIï¼š**

Markdown

# 

`Role: Senior Graphics Engineer
Project: Z-Tide (Web-based Flow-Field Game)
Stack: Vite, React, TypeScript, Pixi.js v8.

**Goal**: Initialize the project and implement the core "Flow Field" swarm engine.

**Task 1: Project Setup**
1. Initialize a Vite + React + TS project. Install `pixi.js` and `@pixi/react`.
2. Create folder structure: 
   - `src/core/map` (FlowField logic)
   - `src/core/render` (Pixi setup)
   - `src/config` (Constants)
3. Set up a full-screen Pixi Application.

**Task 2: Flow Field Algorithm (Crucial)**
1. Create `FlowField.ts`.
2. Manage a 50x50 grid using `Uint8Array` for costs (0=Ground, 255=Wall).
3. Implement `generateIntegrationField(targetX, targetY)` using Dijkstra.
4. Implement `generateVectorField()` to create directional vectors for each cell.
5. Create a Debug View: Draw arrows on the canvas representing the vector field.

**Task 3: Swarm System**
1. Create a `ZombieManager` class.
2. Spawn 2000 entities (simple red circles) at the map edges.
3. In the update loop:
   - Get the vector from the FlowField corresponding to the zombie's grid position.
   - Apply velocity: `vel += vector * speed`.
   - Apply simple separation force (if distance < radius, push away).
4. Render using `PIXI.Container` optimized for particles.

**Constraint**: Focus on performance. Ensure the swarm moves fluidly around obstacles.`

---

## ğŸ“… Phase 2: å•†ä¸šé—­ç¯ â€”â€” "åˆæˆä¸å¡”é˜²" (The Merge Loop)

**å‘¨æœŸç›®æ ‡**ï¼šå°† Tech Demo è½¬åŒ–ä¸ºæ¸¸æˆã€‚åŠ å…¥ SLG æ ¸å¿ƒçš„â€œåˆæˆå‡çº§â€ç©æ³•ã€‚

### 2.1 æ¶æ„è®¾è®¡ï¼šUI ä¸æ¸¸æˆåŒæ­¥

- **React å±‚**ï¼šè´Ÿè´£â€œæ‹–æ‹½åˆæˆâ€ã€‚æ¯ä¸ªæ ¼å­æ˜¯ä¸€ä¸ª `div` (drop target)ã€‚
- **Pixi å±‚**ï¼šè´Ÿè´£â€œå®é™…æˆ˜æ–—â€ã€‚
- **åŒæ­¥æœºåˆ¶**ï¼šä½¿ç”¨ `Zustand` Storeã€‚
    - å½“ React å±‚åˆæˆæˆåŠŸ -> æ›´æ–° Store -> Pixi å±‚ç›‘å¬ Store å˜åŒ– -> é”€æ¯æ—§å¡” Entityï¼Œåˆ›å»ºæ–°ç­‰çº§å¡” Entityã€‚

### 2.2 å¡”é˜²é€»è¾‘

- **ç©ºé—´å“ˆå¸Œ (Spatial Hash)**: ä¸ºäº†æ€§èƒ½ï¼Œå¡”å¯»æ‰¾æ•Œäººæ—¶ä¸¥ç¦åŒé‡å¾ªç¯ã€‚å¿…é¡»å®ç°ä¸€ä¸ªç©ºé—´ç½‘æ ¼ï¼Œåªæ£€æµ‹æ”»å‡»èŒƒå›´å†…çš„æ ¼å­ã€‚
- **æ•°å€¼é…ç½®**: æŠ½ç¦»æ‰€æœ‰æ•°å€¼åˆ° `src/config/Balance.json` (å¦‚ï¼šLv1 ä¼¤å®³ 10ï¼ŒLv2 ä¼¤å®³ 25)ã€‚

### ğŸ’» [IDE Agent æŒ‡ä»¤ - Phase 2]

**è¯·å¤åˆ¶ä»¥ä¸‹å†…å®¹ç»™ä½ çš„ AIï¼š**

Markdown

# 

`Role: Gameplay Engineer
Phase: 2 (Merge & Combat Loop)

**Task 1: The Merge Mechanic (UI Layer)**
1. Create a `useGameStore` with Zustand to store the grid state: `Array<{ type: string, level: number } | null>`.
2. Implement a React UI overlay (Grid System).
3. Implement Drag-and-Drop logic:
   - If dropping Item A (Lv1) onto Item B (Lv1) -> Merge into Lv2.
   - If dropping onto empty slot -> Move.
   - Update the store immediately.

**Task 2: Combat Synchronization**
1. Create a `TowerSystem` in the Pixi engine.
2. Subscribe to `useGameStore`. When the grid updates:
   - If a tower is added/upgraded in the store, spawn/update the corresponding Tower Entity in Pixi.
   - Towers should visually sit exactly where the React UI grid cells are.

**Task 3: Shooting Logic**
1. Implement `SpatialHash` grid for collision detection optimization.
2. Towers scan for the nearest zombie within range using SpatialHash.
3. Spawn `Bullet` entities that travel to the target. 
4. On hit: Deduct Zombie HP. If HP <= 0, remove zombie and add Gold to store.

**Constraint**: Keep the React UI strictly for input/display. All heavy combat math happens in the Pixi loop.`

---

## ğŸ“… Phase 3: å•†ä¸šåŒ–å°è£… â€”â€” "çˆ½æ„Ÿä¸å˜ç°" (Polish & Cash)

**å‘¨æœŸç›®æ ‡**ï¼šæ¥å…¥ä»˜è´¹ç‚¹ï¼Œæ‰“ç£¨è§†è§‰åé¦ˆï¼ˆGame Juiceï¼‰ï¼Œå‡†å¤‡ä¸Šçº¿ã€‚

### 3.1 è§†è§‰æœæ± (Juice)

- **Screen Shake**: åŸºåœ°æ‰£è¡€æ—¶éœ‡åŠ¨ç›¸æœºã€‚
- **Blood Decals**: åƒµå°¸æ­»åï¼Œåœ¨åº•å±‚ Texture ä¸Šç»˜åˆ¶ä¸€æ»©è¡€è¿¹ï¼ˆä¸å¢åŠ  DrawCallï¼‰ã€‚
- **Damage Text**: ä½¿ç”¨ Object Pool å¤ç”¨ä¼¤å®³é£˜å­—ã€‚

### 3.2 å•†ä¸šåŒ–åŸ‹ç‚¹

- **Gacha (æŠ½å¡)**: å®ç°ç®€å•çš„è‹±é›„æŠ½å–é€»è¾‘ï¼ˆSSR/SR/Rï¼‰ï¼Œè·å¾—ç‰¹æ®Šé˜²å¾¡å¡”ã€‚
- **Save System**: å°† Store å†™å…¥ `localStorage`ã€‚

### ğŸ’» [IDE Agent æŒ‡ä»¤ - Phase 3]

**è¯·å¤åˆ¶ä»¥ä¸‹å†…å®¹ç»™ä½ çš„ AIï¼š**

Markdown

# 

`Role: Full Stack Game Dev
Phase: 3 (Polish & Monetization)

**Task 1: Visual Polish (The Juice)**
1. Implement a `ScreenShake` controller in Pixi. Trigger it when the Base takes damage.
2. Create a `BloodSystem`: When a zombie dies, render a static blood sprite into a persistent `RenderTexture` (background layer).
3. Implement an Object Pool for `DamageText` to show numbers when zombies are hit.

**Task 2: Persistence & Meta**
1. Implement `SaveManager`: Save Gold, MaxWave, and GridState to `localStorage` every 10 seconds.
2. Create a simple "Gacha" function in `src/game/Gacha.ts` that returns random loot based on weights.
3. Create a `ShopModal` in React to trigger the Gacha and display results.

**Task 3: FTUE (First Time User Experience)**
1. Create a "Tutorial Overlay" in React that blocks clicks on everything except the highlighted element.
2. Step 1: Force "Buy Tower".
3. Step 2: Force "Merge Tower".
4. Step 3: Force "Start Wave".`

---

### ğŸ’¡ åˆ¶ä½œäººç»™å¼€å‘è€…çš„æœ€åæç¤º

1. **å…ˆåš Phase 1**ã€‚å¦‚æœæµä½“å°¸æ½®çš„æ•ˆæœåšä¸å‡ºæ¥ï¼Œåé¢çš„éƒ½åˆ«åšã€‚
2. **ç¾æœ¯å·æ‡’**ï¼šå¼€å‘é˜¶æ®µï¼Œå¢™=ç°è‰²æ–¹å—ï¼Œå¡”=è“è‰²æ–¹å—ï¼Œåƒµå°¸=çº¢è‰²å°åœ†ç‚¹ã€‚åªè¦åŠ¨èµ·æ¥åƒæ°´æµï¼Œæ¢ä¸Šç¾æœ¯èµ„æºåæ•ˆæœä¼šæå…¶ç‚¸è£‚ã€‚
3. **æ€§èƒ½çº¢çº¿**ï¼šå§‹ç»ˆä¿æŒ Draw Calls < 100ï¼ˆé€šè¿‡ Container æ‰¹å¤„ç†ï¼‰ä»¥åŠ Script Time < 8msã€‚

ç°åœ¨ï¼Œè¯·ç›´æ¥å¤åˆ¶ **[IDE Agent æŒ‡ä»¤ - Phase 1]** å¼€å§‹å·¥ä½œã€‚